# Обработка и валидация форм в React

## Введение

Формы являются неотъемлемой частью веб-приложений. Они позволяют пользователям взаимодействовать с системой, выполняя такие действия, как регистрация, вход в аккаунт, отправка комментариев, заполнение анкет и многое другое. В современных веб-приложениях формы являются одним из самых распространенных способов обмена данными между клиентом и сервером.

Правильная обработка и валидация форм значительно улучшает пользовательский опыт, поскольку позволяет минимизировать ошибки и предотвратить отправку некорректных данных. Реализация эффективной системы валидации обеспечивает надежность приложения и снижает количество потенциальных проблем при обработке пользовательских данных.

## Идея обработки форм в React

Для того чтобы понять принцип обработки форм в React, сначала рассмотрим процесс отправки формы в обычном HTML:

1. Пользователь вводит данные в форму. Поля формы заполняются текстом, числами или другими данными.
2. Пользователь нажимает кнопку `submit`.
3. Данные формы автоматически отправляются на сервер. Адрес для отправки указывается в атрибуте `action` тега `form`.
4. Метод отправки данных определяется атрибутом method (`POST` или `GET`). Это влияет на способ передачи данных на сервер.
5. Сервер обрабатывает полученные данные. После обработки сервер возвращает ответ, который отображается пользователю.
6. Пользователь видит результат. Это может быть страница с сообщением об успехе или ошибке.

Однако такой подход имеет несколько недостатков:

1. Полная перезагрузка страницы при отправке формы, что может быть неудобно для пользователя.
2. Сложности с валидацией данных на стороне клиента до отправки формы.
3. Отсутствие гибкости в обработке ошибок и отображении сообщений.

Перечисленные проблемы можно решить с помощью JavaScript. Перед отправкой данных на сервер можно выполнить валидацию на стороне клиента, а также обработать ответ сервера без перезагрузки страницы. Использование React делает этот процесс более простым и эффективным.

Основная идея обработки форм в React заключается в следующем:

1. Создание контролируемых компонентов. Значение каждого поля формы связывается с состоянием компонента.
2. Отслеживание изменений в полях. При изменении данных вызывается функция обработчика, которая обновляет состояние.
3. Обработка отправки формы. Вместо автоматической отправки используется функция-обработчик события `onSubmit`, которая перехватывает стандартное поведение и предотвращает перезагрузку страницы.
4. Валидация данных на стороне клиента. Перед отправкой данные проверяются на корректность.
5. Отправка данных на сервер через API. Используя методы fetch или axios, данные отправляются асинхронно.
6. Обработка ответа от сервера. После получения ответа приложение обновляет состояние и отображает сообщение пользователю.

В данной главе будут рассмотрены первые четыре пункта: _создание контролируемых компонентов_, _отслеживание изменений_, _обработку отправки формы_ и _валидацию данных на стороне клиента_. В следующей главе мы поговорим о взаимодействии с сервером и обработке ответа.

Также будут рассмотрены два подхода к работе с формами в React: _ручную обработку_ (с использованием контролируемых компонентов и собственных функций валидации) и _работу с библиотекой React Hook Form_ (в сочетании с библиотекой схемной валидации Yup).

## Контролируемые и неконтролируемые компоненты

При создании форм в React разработчик сам управляет состоянием каждого поля и реализует проверку данных. Это позволяет гибко контролировать процесс ввода и валидации. Ключевым понятием здесь являются **контролируемые компоненты**.

**Контролируемые компоненты** — это такие компоненты форм, значения которых полностью управляются состоянием в React. Это значит, что данные, введенные пользователем, не хранятся напрямую в полях ввода (в DOM), а записываются в состояние компонента [^1].

Таким образом, каждое изменение значения в поле вызывает обновление состояния, что позволяет легко отслеживать текущие данные и оперативно проверять их корректность.

В отличие от контролируемых, **неконтролируемые компоненты** хранят данные полей непосредственно в DOM и получают к ним доступ с помощью ссылок (`ref`). Этот подход менее гибкий и сложнее в поддержке, особенно если нужно обрабатывать данные сразу после ввода или проверять их корректность на лету.

> [!NOTE]
> В большинстве случаев рекомендуется использовать контролируемые компоненты, поскольку они дают полный контроль над вводом и облегчают валидацию.

## Ручная обработка форм

### Создание формы и контролируемые компоненты

Начнем с простого примера создания формы с контролируемыми компонентами. Создадим контактную форму с двумя полями: `Имя` и `Email`. Для этого мы используем функциональный компонент React с хуками `useState` для хранения значений этих полей. Также добавим обработчик отправки формы:

**Пример 1**. _Создание формы с контролируемыми компонентами_.

Файл _src/components/ContactForm.jsx_:

```jsx
import { useState } from "react";

function ContactForm() {
  // Состояния для каждого поля формы
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");

  // Обработчик изменения для каждого поля обновляет соответствующее состояние
  // При изменении значения в поле вызывается этот обработчик
  const handleNameChange = (event) => setName(event.target.value);
  const handleEmailChange = (event) => setEmail(event.target.value);

  // Обработчик отправки формы
  const handleSubmit = (event) => {
    // Предотвращаем перезагрузку страницы
    // Если не вызвать preventDefault(), страница будет перезагружена
    event.preventDefault();
    console.log("Данные формы:", { name, email });
    // Здесь могла бы быть отправка на сервер...
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Имя:</label>
        <input type="text" value={name} onChange={handleNameChange} />
      </div>
      <div>
        <label>Email:</label>
        <input type="email" value={email} onChange={handleEmailChange} />
      </div>
      <button type="submit">Отправить</button>
    </form>
  );
}
```

В данном примере:

1. Поля `input` являются контролируемыми, потому что их значение (`value`) привязано к состоянию компонента (`name` и `email`).
   1. При каждом изменении в поле (событие `onChange`) вызывается соответствующая функция (`setName` или `setEmail`), которая обновляет состояние компонента.
   2. Благодаря этому React контролирует содержимое полей и мгновенно обновляет отображаемое значение при каждом изменении. Это позволяет нам всегда иметь актуальные данные в состоянии компонента.
2. При нажатии на кнопку "Отправить" срабатывает событие `onSubmit`, которое вызывает функцию-обработчик `handleSubmit`.
   1. Внутри обработчика используется метод `event.preventDefault()`, который предотвращает стандартное поведение браузера — перезагрузку страницы после отправки формы.
   2. Вместо этого мы выполняем свою логику, например, выводим данные из формы в консоль.
3. Значение каждого поля привязано к состоянию через атрибут `value`. Это гарантирует, что отображаемое значение всегда соответствует состоянию компонента.

4. Поля ввода `input` являются _контролируемыми_: их значение (`value`) привязано к состоянию компонента (`name` и `email`), при каждом изменении (`onChange`) мы вызываем `setName`/`setEmail` для обновления состояния. Это позволяет React контролировать содержимое поля и обновлять состояние при каждом изменении поля.
5. Обработчик `handleSubmit` вызывается при отправке формы (событие onSubmit у `<form>`).
6. Метод `event.preventDefault()` предотвращает стандартное поведение браузера (перезагрузку страницы при отправке формы). Вместо перезагрузки мы выполняем свою логику – здесь просто выводим введенные данные в консоль.
7. Значение поля привязано к состоянию через атрибут `value`. Это позволяет React полностью контролировать содержимое поля.

Чтобы убедиться, как работает привязка данных к состоянию, скопируйте и вставьте приведённый ниже код в Ваш React-проект. При вводе имени и `email` вы увидите, как данные моментально отображаются на экране.

Это происходит благодаря тому, что при каждом изменении в поле ввода обновляется состояние, и React автоматически перерисовывает компонент с новыми значениями.

<details>
  <summary>Посмотреть пример</summary>

  Файл _src/components/ContactForm.jsx_:

  ```jsx
  import { useState } from "react";

  function ContactForm() {
    const [name, setName] = useState("");
    const [email, setEmail] = useState("");

    const handleNameChange = (event) => setName(event.target.value);
    const handleEmailChange = (event) => setEmail(event.target.value);

    const handleSubmit = (event) => {
      event.preventDefault();
      console.log("Данные формы:", { name, email });
    };

    return (
      <form onSubmit={handleSubmit}>
        <div>
          <label>Имя:</label>
          <input type="text" value={name} onChange={handleNameChange} />
          <p>Имя: {name}</p>
        </div>
        <div>
          <label>Email:</label>
          <input type="email" value={email} onChange={handleEmailChange} />
          <p>Email: {email}</p>
        </div>
        <button type="submit">Отправить</button>
      </form>
    );
  }
  ```

  > [!TIP]
  > Событие `onChange` вызывается каждый раз при изменении значения в поле ввода. Это позволяет сразу обновлять состояние компонента и отображать актуальные данные на экране.

</details>

### Базовая валидация данных формы

#### Что такое валидация данных?

Сейчас наша форма принимает любые данные и просто выводит их. Пользователь может ввести что угодно, и это будет считаться корректным. Такой подход может привести к ряду проблем, включая уязвимости и ошибки на сервере. **Запомните золотое правило: Никогда не доверяйте пользовательским данным!**

**Валидация данных** — это процесс проверки введенных пользователем данных на соответствие определенным правилам и требованиям [^2]. Она позволяет убедиться в том, что данные корректны и безопасны перед их дальнейшей обработкой на сервере. Валидация может включать в себя следующие проверки:

- Длина строки (_например_, имя должно содержать от 3 до 50 символов).
- Формат (_например_, email должен соответствовать example@domain.com).
- Числовое значение (_например_, возраст должен быть в диапазоне 18–100 лет).

#### Реализация валидации в React

Добавим валидацию в форму из _Примера 1_. Зададим следующие правила:

- Поля "Имя" и "Email" не должны быть пустыми.
- Имя должно содержать минимум 2 символа.
- Email должен содержать символ `@` и соответствовать общепринятому формату.

Чтобы реализовать валидацию вручную, мы будем проверять значения полей в обработчике отправки и отображать сообщения об ошибках рядом с полями. Для этого нам понадобится состояние для хранения ошибок. Мы создадим объект `errors`, в котором будут храниться сообщения об ошибках для каждого поля, и обновим логику в функции `handleSubmit`.

**Пример 2**. _Добавление валидации вручную_.

Файл _src/components/ContactForm.jsx_:

```jsx
function ContactForm() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  // Состояние для сообщений об ошибках
  const [errors, setErrors] = useState({ name: "", email: "" });

  // ... handleNameChange и handleEmailChange как выше ...

  const handleSubmit = (event) => {
    event.preventDefault();
    let formIsValid = true;
    const formErrors = { name: "", email: "" };

    /*
        Валидация данных:
        - Имя не должно быть пустым и не короче 2 символов
        - Email не должен быть пустым и должен содержать @
    */

    // Проверка поля "Имя"
    if (name.trim() === "") {
      formErrors.name = "Имя не должно быть пустым";
      formIsValid = false;
    } else if (name.length < 2) {
      formErrors.name = "Имя должно быть не короче 2 символов";
      formIsValid = false;
    }

    // Проверка поля "Email"
    if (email.trim() === "") {
      formErrors.email = "Email не должен быть пустым";
      formIsValid = false;
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      formErrors.email = "Некорректный формат email";
      formIsValid = false;
    }

    setErrors(formErrors);

    if (formIsValid) {
      // Если все проверки прошли, можно отправлять данные
      console.log("Форма валидна, данные: ", { name, email });
      // ...здесь могла бы быть отправка данных на сервер...
      // Дополнительно можно очистить форму:
      setName("");
      setEmail("");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Имя:</label>
        <input type="text" value={name} onChange={handleNameChange} />
        {/* Вывод сообщения об ошибке для имени */}
        {errors.name && <div className="error">{errors.name}</div>}
      </div>
      <div>
        <label>Email:</label>
        <input type="email" value={email} onChange={handleEmailChange} />
        {/* Вывод сообщения об ошибке для email */}
        {errors.email && <div className="error">{errors.email}</div>}
      </div>
      <button type="submit">Отправить</button>
    </form>
  );
}
```

В этом примере:

1. При клике на кнопку «Отправить» `handleSubmit` проверяет каждое поле.
2. Если какое-то из условий не выполняется, мы отмечаем `formIsValid = false` и записываем сообщение об ошибке в `formErrors`.
3. После проверок обновляем состояние errors вызовом `setErrors(formErrors)`, что приводит к повторному рендеру компонента.
4. В JSX-части у каждого поля был добавлен вывод сообщения об ошибке: например, `{errors.name && <div className="error">{errors.name}</div>}` отобразит `<div>` с текстом ошибки, если для name есть непустое сообщение об ошибке в состоянии.

Таким образом, пользователь сразу увидит сообщения, какие поля нужно исправить.

> [!NOTE]
> Заметьте, что в данном подходе мы вручную пишем однообразный код для отслеживания каждого поля и каждой возможной ошибки. При большом количестве полей этот код разрастается, и его поддержка становится сложнее. Тем не менее, понимание этой «кухни» важно: ручной подход лежит в основе и дает понимание, как React обрабатывает ввод.

### Использование объекта для хранения данных формы

Когда в форме много полей, использование отдельных состояний для каждого из них может быть неудобным и неэффективным. Вместо этого лучше хранить все данные формы в одном объекте состояния. Это позволяет легко управлять полями и передавать данные в другие компоненты или функции.

**Пример 3**. _Использование объекта для хранения данных формы_.

Файл _src/components/ContactForm.jsx_:

```jsx
import { useState } from "react";

function ContactForm() {
  // Состояние формы хранится в одном объекте
  const [formData, setFormData] = useState({ name: "", email: "" });
  const [errors, setErrors] = useState({ name: "", email: "" });

  // Обработчик изменения поля ввода
  const handleChange = (event) => {
    const { name, value } = event.target;
    // Обновляем состояние с помощью деструктуризации
    setFormData((prevData) => ({ ...prevData, [name]: value }));
  };

  // Обработчик отправки формы с валидацией
  const handleSubmit = (event) => {
    event.preventDefault();
    let formIsValid = true;
    const formErrors = { name: "", email: "" };

    // Валидация поля "Имя"
    if (formData.name.trim() === "") {
      formErrors.name = "Имя не должно быть пустым";
      formIsValid = false;
    } else if (formData.name.length < 2) {
      formErrors.name = "Имя должно содержать не менее 2 символов";
      formIsValid = false;
    }

    // Валидация поля "Email"
    if (formData.email.trim() === "") {
      formErrors.email = "Email не должен быть пустым";
      formIsValid = false;
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      formErrors.email = "Некорректный формат email";
      formIsValid = false;
    }

    // Обновляем состояние ошибок
    setErrors(formErrors);

    if (formIsValid) {
      console.log("Форма валидна, данные:", formData);
      // Здесь могла бы быть отправка данных на сервер...
      // Очистка полей формы после успешной отправки
      setFormData({ name: "", email: "" });
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Имя:</label>
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleChange}
        />
        {errors.name && <div className="error">{errors.name}</div>}
      </div>
      <div>
        <label>Email:</label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
        />
        {errors.email && <div className="error">{errors.email}</div>}
      </div>
      <button type="submit">Отправить</button>
    </form>
  );
}

export default ContactForm;
```

## Использование библиотеки React Hook Form

**React Hook Form (далее RHF)** [^3] – легковесная библиотека для управления формами в React, построенная на хуках. Она позволяет значительно сократить объем кода формы и автоматизировать большинство задач: хранение и обновление значений полей, отслеживание ошибок, валидация и т.д.

> [!TIP]
> RHF добивается высокой производительности благодаря использованию концепции неконтролируемых компонентов (то есть опирается на прямой доступ к элементам DOM через рефы вместо хранения каждого символа в состоянии) – это минимизирует количество повторных рендеров и улучшает быстродействие приложения

### Установка и подключение библиотеки

Чтобы начать использовать React Hook Form

```bash
npm install react-hook-form
```

### Основные принципы React Hook Form

1. **Контроль формы через хуки**. Вместо создания отдельных состояний для каждого поля формы, RHF предоставляет хуки для управления всей формой. Это упрощает код и уменьшает объем состояний.
2. **Работа с неконтролируемыми компонентами**. RHF использует неконтролируемые компоненты для управления формой. Это позволяет снизить количество повторных рендеров и улучшить производительность.
3. **Валидация и отслеживание ошибок**. RHF предоставляет удобные методы для валидации данных и отображения ошибок. Это позволяет легко проверять данные и предотвращать отправку некорректных данных.
4. **Автоматическое обновление данных**. RHF автоматически обновляет данные формы при вводе пользователя. Это позволяет мгновенно отображать изменения и улучшает пользовательский опыт.

### Создание формы с React Hook Form

Перепишем форму из _Примера 1_, используя библиотеку React Hook Form (RHF). Эта библиотека позволяет значительно упростить работу с формами за счет использования хуков, таких как `useForm`, `register`, `handleSubmit`, а также автоматической обработки ошибок.

**Пример 4**. _Создание формы с React Hook Form_.

Файл _src/components/ContactForm.jsx_:

```jsx
import { useForm } from "react-hook-form";

function ContactForm() {
  // Используем хук useForm для получения методов работы с формой
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm();

  // Функция обработки отправки формы
  const onSubmit = (data) => {
    console.log("Данные формы:", data);
    // Здесь могла бы быть отправка данных на сервер
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>Имя:</label>
        <input
          type="text"
          {...register("name", {
            required: "Имя обязательно",
            minLength: {
              value: 2,
              message: "Имя должно содержать не менее 2 символов",
            },
          })}
        />
        {/* Вывод сообщения об ошибке для имени */}
        {errors.name && <div className="error">{errors.name.message}</div>}
      </div>

      <div>
        <label>Email:</label>
        <input
          type="email"
          {...register("email", {
            required: "Email обязателен",
            pattern: {
              value: /\S+@\S+\.\S+/,
              message: "Некорректный формат email",
            },
          })}
        />
        {/* Вывод сообщения об ошибке для email */}
        {errors.email && <div className="error">{errors.email.message}</div>}
      </div>

      <button type="submit">Отправить</button>
    </form>
  );
}

export default ContactForm;
```

В данном коде:

1. Хук `useForm`, чтобы получить необходимые методы и объекты для работы с формой:
   - `register` — функция для связывания полей формы с системой RHF.
   - `handleSubmit` — функция-обработчик отправки формы.
   - `errors` — объект, содержащий ошибки валидации.
2. Каждое поле связывается с формой через `{...register('<имя поля>')}`.
   1. Мы указываем имя поля ("name") и объект с правилами валидации:
      - `required` — делает поле обязательным и выводит сообщение об ошибке, если поле пустое.
      - `minLength` — задает минимальное количество символов и сообщение в случае несоответствия.
      - `pattern` — проверяет формат поля с помощью регулярного выражения.
3. Обработчик отправки формы кардинально упростился: Функция `onSubmit` оборачивается вызовом `handleSubmit(onSubmit)`. RHF сам вызовет `onSubmit` только если данные прошли валидацию. В противном случае произойдет предотвращение отправки и заполнение объекта `errors`.
4. Объект `errors` содержит ошибки валидации для полей (если они есть). Если, например, поле `name` не заполнено, то `errors.name` будет объектом с сообщением об ошибке.

При использовании RHF каждый ввод в поле обновляет данные формы напрямую через отслеживаемые рефы (используя `ref`), а не через состояние компонента. Это позволяет:

- Избежать ненужных перерисовок компонента при каждом вводе символа.
- Поддерживать высокую производительность даже на больших формах.
- Работать с данными формы более гибко и удобно.

В отличие от классического подхода, нам не нужно вручную вызывать `event.preventDefault()`. RHF делает это автоматически внутри функции `handleSubmit`, предотвращая стандартное поведение формы. Это упрощает код и делает его более чистым.

#### Представление данных формы

​В библиотеке React Hook Form данные, введённые пользователем в поля формы, автоматически собираются в объект. Этот объект представляет собой структуру, где ключами являются имена полей формы, а значениями — соответствующие введённые данные.

Рассмотрим пример: если пользователь ввёл в поле name значение `'John'`, а в поле `email` — `'john@gmail.com'`, то при отправке формы объект будет выглядеть следующим образом:​

```js
{
    name: 'John',
    email: 'john@gmail.com'
}
```

Функция `onSubmit` получает этот объект и может использовать его для дальнейшей обработки, например, для отправки данных на сервер или отображения в интерфейсе.

#### Работа с начальными значениями (defaultValues)

При создании формы с React Hook Form можно указать начальные значения для всех полей, которые должны быть установлены при загрузке формы. Для этого используется параметр `defaultValues` в хукe `useForm`.

**Пример 5**. _Установка начальных значений для полей формы_.

```js
const { register, handleSubmit } = useForm({
  defaultValues: {
    name: "John",
    email: "john@example.com",
  },
});
```

Эти значения автоматически отобразятся в полях ввода, и будут считаться "исходными" для отслеживания изменений.

#### Настройка поведения валидации с помощью mode

Параметр `mode` в `useForm` определяет, когда должна запускаться валидация полей формы. По умолчанию, React Hook Form выполняет валидацию при отправке формы (`onSubmit`). Однако вы можете изменить это поведение, если нужно, чтобы ошибки показывались сразу при вводе или потере фокуса.

Возможные значения `mode`:

| Значение      | Поведение                                                            |
| ------------- | -------------------------------------------------------------------- |
| `"onSubmit"`  | (по умолчанию) Валидация происходит только при отправке формы.       |
| `"onChange"`  | Валидация выполняется при каждом изменении значения в поле.          |
| `"onBlur"`    | Валидация запускается при потере фокуса с поля.                      |
| `"onTouched"` | Валидация происходит после первого взаимодействия с полем.           |
| `"all"`       | Валидация выполняется при всех событиях: `onChange`, `onBlur` и т.д. |

**Пример 6**. _Настройка поведения валидации_.

```js
const {
  register,
  handleSubmit,
  formState: { errors },
} = useForm({
  mode: "onChange", // ошибки будут отображаться сразу при вводе
});
```

#### Сброс и обновление формы с помощью reset

Функция `reset()` в React Hook Form используется для сброса значений формы к указанным значениям. Это удобно в следующих случаях:

- Нужно очистить форму после успешной отправки.
- Нужно загрузить новые данные (например, при редактировании пользователя).
- Нужно вернуть форму к начальному состоянию, если пользователь нажал "Отмена".

**Пример 7**. _Сброс формы после успешной отправки_.

```js
const { register, handleSubmit, reset } = useForm();

const onSubmit = (data) => {
  console.log(data);
  // Отправка данных, затем сброс формы
  reset(); // сбрасывает к пустым значениям
};
```

**Пример 8**. _Сброс с новыми начальными значениями_.

```js
const defaultUser = {
  name: "Alice",
  email: "alice@example.com",
};

const { register, handleSubmit, reset } = useForm({
  defaultValues: defaultUser,
});

const loadNewUser = () => {
  const anotherUser = {
    name: "Bob",
    email: "bob@example.com",
  };
  reset(anotherUser); // заменит значения в форме
};
```

**Пример 9**. _Сброс, но с сохранением ошибок_.

```js
reset({}, { keepErrors: true });
```

### Работа с различными типами полей формы в React Hook Form

React Hook Form (RHF) позволяет легко интегрировать не только обычные текстовые поля, но и различные другие элементы формы: `select`, `radio`, `checkbox`, `textarea`, `multiselect` и т.д. Все они обрабатываются через `register` или с помощью `Controller` для более сложных случаев (_не будет рассмотрено в этой главе_).

#### Select (выпадающий список)

**Пример 10**. _Создание выпадающего списка с React Hook Form_.

```jsx
<select {...register("gender")}>
  <option value="">Выберите пол</option>
  <option value="male">Мужской</option>
  <option value="female">Женский</option>
</select>
```

Данные в `onSubmit` будут будут доступны как: `{ gender: "male" }`.

_Примечание_: Если у вас большое количество значений, элементы `<option>` можно сгенерировать в цикле на основе массива.

**Пример 11**. _Создание выпадающего списка с помощью цикла на основе массива_.

```jsx
const genders = [
  { value: "male", label: "Мужской" },
  { value: "female", label: "Женский" },
  { value: "other", label: "Другое" },
];

<select {...register("gender")}>
  <option value="">Выберите пол</option>
  {genders.map((gender) => (
    <option key={gender.value} value={gender.value}>
      {gender.label}
    </option>
  ))}
</select>;
```

#### Radio (одиночный выбор)

Радио-кнопки объединяются по `name`, но каждая имеет своё `value`.

**Пример 12**. _Создание радио-кнопок с React Hook Form_.

```jsx
<label>
  <input type="radio" value="yes" {...register("subscribe")} />
  Да
</label>
<label>
  <input type="radio" value="no" {...register("subscribe")} />
  Нет
</label>
```

Данные в `onSubmit` будут доступны как: `{ subscribe: "yes" }` или `{ subscribe: "no" }`

#### Checkbox (мультифлажки и одиночный флаг)

Одиночный флажок (булево значение):

**Пример 13**. _Создание одиночного флажка с React Hook Form_.

```jsx
<label>
  <input type="checkbox" {...register("agree")} />
  Согласен с условиями
</label>
```

Данные в `onSubmit` будут доступны как: `{ agree: true }` или `{ agree: false }`.

Группа флажков (выбор нескольких значений):

**Пример 14**. _Создание группы флажков с React Hook Form_.

```jsx
<label>
  <input type="checkbox" value="html" {...register("skills")} />
  HTML
</label>
<label>
  <input type="checkbox" value="css" {...register("skills")} />
  CSS
</label>
<label>
  <input type="checkbox" value="js" {...register("skills")} />
  JavaScript
</label>
```

Данные в `onSubmit` будут доступны как: `{ skills: ["html", "css"] }` — массив выбранных значений

#### Multiselect (множественный выбор в select)

**Пример 15**. _Создание мультиселекта с React Hook Form_.

```jsx
<select multiple {...register("languages")}>
  <option value="ru">Русский</option>
  <option value="en">Английский</option>
  <option value="de">Немецкий</option>
</select>
```

Данные в `onSubmit` будут доступны как: `{ languages: ["ru", "en"] }` - массив выбранных значений.

#### Textarea

Textarea не отличается от обычного текстового поля, но позволяет вводить многострочный текст.

**Пример 16**. _Создание текстовой области с React Hook Form_.

```jsx
<textarea {...register("message")}></textarea>
```

Данные в `onSubmit` будут доступны как: `{ message: "Привет, мир!" }`.

#### Рекомендации

- Всегда используйте `value` у `radio`, `checkbox` и `option`.
- Проверяйте, что `defaultValues` соответствуют ожидаемому типу (строка, массив, булево).

### Валидация формы при помощи библиотеки Yup

В предыдущих примерах мы реализовали валидацию формы с использованием встроенных средств React Hook Form (RHF). Однако, при работе с более сложными формами ручная валидация может становиться громоздкой и трудно поддерживаемой.

Чтобы упростить процесс и сделать его более гибким, можно использовать специализированные библиотеки валидации. Одной из самых популярных является Yup. Она позволяет создавать схемы валидации с четко заданными правилами и удобно интегрировать их с RHF.

**Yup** [^4] — это библиотека для валидации данных в JavaScript. Она позволяет создавать схемы валидации с помощью цепочки методов, поддерживая:

- Проверку строк, чисел, дат и других типов данных.
- Задание минимальной и максимальной длины.
- Проверку формата (например, `email` или `URL`).
- Пользовательские сообщения об ошибках.
- Композицию сложных правил.

#### Установка и подключение Yup

Для использования Yup с React Hook Form необходимо установить пакеты `yup` и `@hookform/resolvers`:

```bash
npm install yup @hookform/resolvers
```

_Примечание_: Пакет `@hookform/resolvers` содержит готовые адаптеры для интеграции схем валидации (Yup, Zod и др.) с React Hook Form.

#### Использование Yup для валидации формы

Для использования Yup в React Hook Form необходимо создать схему валидации с помощью Yup и передать ее в метод `useForm` в качестве резолвера. Это позволяет автоматически валидировать данные формы и отображать сообщения об ошибках.

**Пример 17**. _Создание схемы валидации с Yup_.

Файл _src/validation/contact.schema.js_:

```jsx
import * as yup from "yup";

// Определяем схему валидации для полей формы
const schema = yup
  .object({
    name: yup
      .string()
      .required("Имя не должно быть пустым")
      .min(2, "Имя должно содержать не менее 2 символов"),
    email: yup
      .string()
      .required("Email не должен быть пустым")
      .email("Некорректный формат email"),
  })
  .required();

export default schema;
```

- **Структура схемы**. Мы используем объект `yup.object()` для создания схемы.
  - Поле `name`: проверяется на то, что оно является строкой, не пустое и содержит минимум 2 символа.
  - Поле `email`: проверяется на соответствие формату `email`.
- **Сообщения об ошибках**. Каждое правило валидации сопровождается сообщением, которое будет отображено при нарушении условия.

> [!NOTE]
> Подробная документация по Yup доступна на официальном сайте: https://github.com/jquense/yup

**Пример 18**. _Использование схемы валидации в React Hook Form_.

Файл _src/components/ContactForm.jsx_:

```jsx
import { useForm } from "react-hook-form";

import { yupResolver } from "@hookform/resolvers/yup";

import schema from "../validation/contact.schema";

function ContactForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    // Передаем схему валидации в качестве резолвера
    resolver: yupResolver(schema),
  });

  const onSubmit = (data) => {
    console.log("Данные формы:", data);
    // Здесь могла бы быть отправка данных на сервер
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>Имя:</label>
        <input type="text" {...register("name")} />
        {errors.name && <div className="error">{errors.name.message}</div>}
      </div>

      <div>
        <label>Email:</label>
        <input type="email" {...register("email")} />
        {errors.email && <div className="error">{errors.email.message}</div>}
      </div>

      <button type="submit">Отправить</button>
    </form>
  );
}

export default ContactForm;
```

В этом примере:

1. В хук `useForm`, передается резолвер `yupResolver(schema)`, который связывает форму с созданной схемой валидации.
2. Схема валидации перенесена отдельный файл _contact.schema.js_.
3. Функция `register` используется для связывания полей с формой и `errors` для отображения сообщений об ошибках.
4. Если данные формы прошли валидацию, вызывается функция `onSubmit`, которая выводит данные в консоль.

### Управление динамическими полями формы

Когда мы создаём формы в веб-приложениях, часто структура формы может меняться в зависимости от действий пользователя. Иногда мы не знаем заранее, сколько будет таких полей — например, пользователю может потребоваться ввести несколько номеров телефонов, список email-адресов, образование, опыт работы или перечень ссылок на портфолио. В таких случаях на помощь приходят динамические поля формы.

**Динамические поля** — это такие поля формы, которые могут добавляться или удаляться пользователем по мере необходимости прямо во время работы с формой. Это делает интерфейс гибким и удобным, адаптируясь под реальную ситуацию пользователя.

**Примеры**:

- Пользователь добавляет несколько телефонов или email-адресов.
- В резюме человек указывает несколько мест работы.
- В интернет-магазине — список товаров, добавленных вручную в заказ.
- В системе анкетирования — возможность добавить неограниченное количество ответов на вопрос.

Чтобы реализовать такую функциональность в React-приложении, можно использовать разные подходы — вручную управлять массивом полей или использовать специализированные хук `useFieldArray` [^5].

**Пример 19**. _Управление динамическими полями формы_.

Файл _src/components/DynamicForm.jsx_:

```jsx
import React from "react";
import { useForm, useFieldArray } from "react-hook-form";

function DynamicForm() {
  const { register, control, handleSubmit } = useForm({
    defaultValues: {
      names: [""],
    },
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: "names",
  });

  const onSubmit = (data) => {
    console.log("Отправленные данные:", data);
    // Здесь можно добавить логику отправки данных на сервер
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {fields.map((field, index) => (
        <div key={field.id}>
          {/* Каждое поле связано с массивом `names` через индекс */}
          <input {...register(`names.${index}`)} defaultValue={field.value} />
          <button type="button" onClick={() => remove(index)}>
            Удалить
          </button>
        </div>
      ))}
      <button type="button" onClick={() => append("")}>
        Добавить поле
      </button>
      <button type="submit">Отправить</button>
    </form>
  );
}

export default DynamicForm;
```

**В этом примере**:

- `useForm` инициализирует форму с полем names, которое представляет массив строк
- `useFieldArray` управляет этим массивом и возвращает:
  - `fields` — массив объектов, представляющих текущие поля формы.
  - `append()` — функция для добавления нового поля.
    - Функция `append()` принимает аргумент, соответствующий структуре одного элемента массива, указанного в `name`. _Например_, если вы работаете с массивом простых значений (`names: [""]`), вы можете передавать просто строки: `append("Новое имя")`.
    - `append()` добавляет новый элемент в массив names, а _форма автоматически отобразит для него поля ввода_.
  - `remove(index)` — функция для удаления поля по индексу.
- Параметр `name` в `useFieldArray` указывает, с каким массивом в структуре формы будет работать `useFieldArray`. _Например_, если вы указали `name: "names"`, это означает, что поля будут храниться в `formData.names`, то есть массив значений будет находиться по этому ключу.
- Поля рендерятся по данным из `fields`, каждое имеет уникальный `key` (`field.id`).
- При отправке формы (`handleSubmit`), все значения из массива `names` автоматически собираются в объект и передаются в `onSubmit`.

#### Валидация динамических полей с использованием Yup

Для валидации динамических полей формы с использованием Yup, необходимо создать схему валидации, которая будет применяться к каждому элементу массива. Для этого можно использовать метод `array().of()`.

**Пример 20**. _Валидация динамических полей с использованием Yup_.

Файл _src/validation/dynamic.schema.js_:

```jsx
const schema = yup.object().shape({
  names: yup
    .array()
    .of(yup.string().required("Поле обязательно для заполнения")),
});
```

**Примечание**: В данном примере мы создаем схему валидации, которая проверяет, что каждый элемент массива `names` является строкой и не пустым.

**Пример 21**. _Использование схемы валидации для динамических полей_.

Файл _src/components/DynamicForm.jsx_:

```jsx
import React from "react";
import { useForm, useFieldArray } from "react-hook-form";
import { yupResolver } from "@hookform/resolvers/yup";
import schema from "../validation/dynamic.schema";

function DynamicForm() {
  const {
    register,
    control,
    handleSubmit,
    formState: { errors },
  } = useForm({
    defaultValues: {
      names: [""],
    },
    resolver: yupResolver(schema),
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: "names",
  });

  const onSubmit = (data) => {
    console.log("Отправленные данные:", data);
    // Здесь можно добавить логику отправки данных на сервер
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {fields.map((field, index) => (
        <div key={field.id}>
          <input {...register(`names.${index}`)} defaultValue={field.value} />
          {errors.names && errors.names[index] && (
            <p>{errors.names[index].message}</p>
          )}
          <button type="button" onClick={() => remove(index)}>
            Удалить
          </button>
        </div>
      ))}
      <button type="button" onClick={() => append("")}>
        Добавить поле
      </button>
      <button type="submit">Отправить</button>
    </form>
  );
}

export default DynamicForm;
```

## Recap: Обработка и валидация форм в React

### Основы работы с формами

- Формы позволяют пользователю взаимодействовать с приложением и отправлять данные.
- В классическом HTML отправка формы вызывает полную перезагрузку страницы.
- В React формы обрабатываются через JavaScript, что обеспечивает:
  - отсутствие перезагрузки,
  - валидацию на клиенте,
  - асинхронную отправку данных через `fetch` или `axios`.

### Контролируемые компоненты

- **Контролируемые поля** — поля, значение которых связано с состоянием компонента (`useState`).
- Используются `value` и `onChange` для синхронизации данных.
- Подход удобен для ручной валидации и отображения ошибок, но может стать громоздким при большом числе полей.

### Ручная валидация

- Валидация реализуется вручную в `handleSubmit`.
- Ошибки хранятся в отдельном объекте `errors`.
- Минусы: много повторяющегося кода при большом количестве полей.

### React Hook Form (RHF)

- Легковесная библиотека для работы с формами, использующая `ref` вместо `useState`.
- Предоставляет хуки: `useForm`, `register`, `handleSubmit`, `formState.errors` и др.
- Преимущества:
  - Меньше ререндеров,
  - Простота,
  - Отличная интеграция с валидацией (в т.ч. Yup),
  - Поддержка динамических полей (`useFieldArray`).

### Основные возможности `useForm`

- `defaultValues` — начальные значения полей.
- `mode` — когда запускать валидацию (`onSubmit`, `onChange`, `onBlur` и др.).
- `reset()` — сброс формы (очистка или установка новых значений).

### Поддерживаемые типы полей

| Тип поля           | Как использовать с RHF                   | Результат при submit                     |
| ------------------ | ---------------------------------------- | ---------------------------------------- |
| `input`            | `{...register("field")}`                 | `{ field: "значение" }`                  |
| `select`           | `<select {...register("option")}>`       | `{ option: "выбранное_значение" }`       |
| `radio`            | `<input type="radio" {...register()}>`   | `{ field: "selected_value" }`            |
| `checkbox`         | одиночный: булево, множественные: массив | `{ checked: true }` или `{ skills: [] }` |
| `textarea`         | `<textarea {...register("text")}>`       | `{ text: "многострочный текст" }`        |
| `select[multiple]` | `<select multiple {...register()}>`      | `{ field: [ "val1", "val2" ] }`          |

### Динамические поля (`useFieldArray`)

- Позволяют добавлять и удалять поля на лету (например, список телефонов).
- Используются вместе с `control` и `register`.
- Методы:
  - `append()` — добавить элемент,
  - `remove(index)` — удалить элемент по индексу.
- Поддерживает валидацию как вручную, так и через Yup (`array().of()`).

### Валидация с Yup

- Yup — библиотека для схемной валидации.
- Используется вместе с RHF через `yupResolver(schema)`.
- Позволяет описывать требования к полям декларативно и централизованно.
- Поддерживает валидацию массивов, вложенных объектов, цепочки правил и кастомные сообщения об ошибках.

[^1]: _Неконтролируемые компоненты в React_. habr.com [online resource]. Available at: https://habr.com/ru/articles/319520/
[^2]: Nartea Nichita. _Фильтрация и валидация данных форм_. github.com [online resource]. Available at: https://github.com/MSU-Courses/advanced-web-programming/blob/main/07_Forms_And_Validation/07_04_Form_Validation.md
[^3]: _React Hook Form_. react-hook-form.com [online resource]. Available at: https://react-hook-form.com
[^4]: _Yup_. github.com [online resource]. Available at: https://github.com/jquense/yup
[^5]: _useFieldArray_. react-hook-form.com [online resource]. Available at: https://www.react-hook-form.com/api/usefieldarray/